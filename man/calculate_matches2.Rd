% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_matches2.R
\name{calculate_matches2}
\alias{calculate_matches2}
\title{Calculates matches for one or more children by blended distance matching}
\usage{
calculate_matches2(
  data,
  newdata,
  y_name = character(0L),
  x_name = character(0L),
  e_name = character(0L),
  t_name = character(0L),
  subset = TRUE,
  k = 10L,
  replace = FALSE,
  blend = 1,
  break_ties = TRUE,
  kappa = 3,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{data}{A \code{data.frame} or \code{tbl_df} with donor data. One row is
one potential donor.}

\item{newdata}{A \code{data.frame} or \code{tbl_df} with data of children for
which we seek matches. Every row corresponds to one child.}

\item{y_name}{A character vector containing the names of the dependent
variables in \code{data}.}

\item{x_name}{A character vector containing the names of predictive variables
in \code{data} to will go into the linear part of the model.}

\item{e_name}{A character vector containing the names of the variables for
which the match should be exact.}

\item{t_name}{A character vector containing the names of the treatment
variables in \code{data}. The current function will only fit the model to
only the first element of \code{t_name}.}

\item{subset}{Logical expression defining the set of rows taken from
\code{data}. This subset is selected before any other calculations are
made, and this can be used to trim down the size of the data in which
matches are defined and sought.}

\item{k}{Requested number of matches. The default is \code{k = 10}.}

\item{replace}{A logical that indicates whether to match with or without
replacement. The default is \code{FALSE}.}

\item{blend}{An integer value between 0 and 1 that indicates the blend
between predictive mean matching with replacement (\code{1}) and euclidian
distance matching (\code{0}). The default is \code{1}.}

\item{break_ties}{A logical indicating whether ties should broken randomly.
The default (\code{TRUE}) breaks ties randomly.}

\item{kappa}{A numeric value that serves as the sensitivity parameter for the
inverse distance weighting. Used when drawing with replacement. The default
is \code{3}.}

\item{verbose}{A logical indicating whether diagnostic information should be
printed.}

\item{\dots}{Arguments passed down to \code{match_pmm()}.}
}
\value{
An object of class \code{match_list} which can be post-processed by
  the \code{extract_matches} function to extract the row numbers in
  \code{data} of the matched children. The length of the list will be always
  equal to \code{m} if \code{replace == TRUE}, but may be shorter if
  \code{replace == FALSE} if the donors are exhausted. The length is zero if
  no matches can be found.
}
\description{
Curve matching is a technology that aims to predict individual growth curves.
The method finds persons similar to the target person, and learn the possible
future course of growth from the realized curves of the matched individuals.
}
\details{
The function finds \code{k} matches for an individual in the same data set by
means of stratified predictive mean matching or by nearest neighbour matching.


  The procedure search for matches in \code{data} for each row
  in \code{newdata}.
  Note that if \code{x_name} contains one or more factors, then it is
  possible that the factor level of the target case is unique among all
  potential donors. In that case, the model can still be fit, but prediction
  will fail, and hence no matches will be found.

  If \code{break_ties} is \code{FALSE}, the function returns the first \code{nmatch}
  matches as they appear in the order of \code{data}. This method overuses
  the first part of the data if there are ties, and hence may underestimate
  variability. The default option is to break ties randomly.
}
\examples{
data <- datasets::ChickWeight
data[1, ]

# find matches for observation in row 1
m1 <- calculate_matches2(data, data[1, ], subset = !rownames(data) \%in\% "1",
    y_name = "weight", x_name = c("Time", "Diet"))

# data of matched cases (may vary because of tie breaking)
data[extract_matches(m1), ]

# without tie breaking, we pick the earlier rows (not recommended)
m2 <- calculate_matches2(data, data[1, ], subset = !rownames(data) \%in\% "1",
     y_name = "weight", x_name = c("Time", "Diet"), break_ties = FALSE)
data[extract_matches(m2), ]

}
\references{
van Buuren, S. (2014). \emph{Curve matching: A data-driven
  technique to improve individual prediction of childhood growth}. Annals of
  Nutrition & Metabolism, 65(3), 227-233. van Buuren, S. (2012).
  \emph{Flexible imputation of missing data}. Boca Raton, FL: Chapman &
  Hall/CRC.
}
\author{
Stef van Buuren 2021
}
